// Code generated by MockGen. DO NOT EDIT.
// Source: internal/domain/service/notification_aggregator.go
//
// Generated by this command:
//
//	mockgen -source=internal/domain/service/notification_aggregator.go -destination=internal/domain/service/mocks/mock_notification_aggregator.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	entity "github.com/aiagent/internal/domain/entity"
	uuid "github.com/google/uuid"
	gomock "go.uber.org/mock/gomock"
)

// MockNotificationAggregator is a mock of NotificationAggregator interface.
type MockNotificationAggregator struct {
	ctrl     *gomock.Controller
	recorder *MockNotificationAggregatorMockRecorder
	isgomock struct{}
}

// MockNotificationAggregatorMockRecorder is the mock recorder for MockNotificationAggregator.
type MockNotificationAggregatorMockRecorder struct {
	mock *MockNotificationAggregator
}

// NewMockNotificationAggregator creates a new mock instance.
func NewMockNotificationAggregator(ctrl *gomock.Controller) *MockNotificationAggregator {
	mock := &MockNotificationAggregator{ctrl: ctrl}
	mock.recorder = &MockNotificationAggregatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNotificationAggregator) EXPECT() *MockNotificationAggregatorMockRecorder {
	return m.recorder
}

// CheckRateLimit mocks base method.
func (m *MockNotificationAggregator) CheckRateLimit(ctx context.Context, userID uuid.UUID, notifType entity.NotificationType) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckRateLimit", ctx, userID, notifType)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CheckRateLimit indicates an expected call of CheckRateLimit.
func (mr *MockNotificationAggregatorMockRecorder) CheckRateLimit(ctx, userID, notifType any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckRateLimit", reflect.TypeOf((*MockNotificationAggregator)(nil).CheckRateLimit), ctx, userID, notifType)
}

// IncrementRateLimit mocks base method.
func (m *MockNotificationAggregator) IncrementRateLimit(ctx context.Context, userID uuid.UUID, notifType entity.NotificationType) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IncrementRateLimit", ctx, userID, notifType)
	ret0, _ := ret[0].(error)
	return ret0
}

// IncrementRateLimit indicates an expected call of IncrementRateLimit.
func (mr *MockNotificationAggregatorMockRecorder) IncrementRateLimit(ctx, userID, notifType any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IncrementRateLimit", reflect.TypeOf((*MockNotificationAggregator)(nil).IncrementRateLimit), ctx, userID, notifType)
}

// ShouldAggregate mocks base method.
func (m *MockNotificationAggregator) ShouldAggregate(ctx context.Context, userID uuid.UUID, notifType entity.NotificationType, targetID uuid.UUID) (*entity.Notification, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ShouldAggregate", ctx, userID, notifType, targetID)
	ret0, _ := ret[0].(*entity.Notification)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ShouldAggregate indicates an expected call of ShouldAggregate.
func (mr *MockNotificationAggregatorMockRecorder) ShouldAggregate(ctx, userID, notifType, targetID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ShouldAggregate", reflect.TypeOf((*MockNotificationAggregator)(nil).ShouldAggregate), ctx, userID, notifType, targetID)
}

// MockFirebaseAdapter is a mock of FirebaseAdapter interface.
type MockFirebaseAdapter struct {
	ctrl     *gomock.Controller
	recorder *MockFirebaseAdapterMockRecorder
	isgomock struct{}
}

// MockFirebaseAdapterMockRecorder is the mock recorder for MockFirebaseAdapter.
type MockFirebaseAdapterMockRecorder struct {
	mock *MockFirebaseAdapter
}

// NewMockFirebaseAdapter creates a new mock instance.
func NewMockFirebaseAdapter(ctrl *gomock.Controller) *MockFirebaseAdapter {
	mock := &MockFirebaseAdapter{ctrl: ctrl}
	mock.recorder = &MockFirebaseAdapterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFirebaseAdapter) EXPECT() *MockFirebaseAdapterMockRecorder {
	return m.recorder
}

// SendPush mocks base method.
func (m *MockFirebaseAdapter) SendPush(ctx context.Context, deviceTokens []string, title, body string, data map[string]any) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SendPush", ctx, deviceTokens, title, body, data)
	ret0, _ := ret[0].(error)
	return ret0
}

// SendPush indicates an expected call of SendPush.
func (mr *MockFirebaseAdapterMockRecorder) SendPush(ctx, deviceTokens, title, body, data any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendPush", reflect.TypeOf((*MockFirebaseAdapter)(nil).SendPush), ctx, deviceTokens, title, body, data)
}

// SendPushToUser mocks base method.
func (m *MockFirebaseAdapter) SendPushToUser(ctx context.Context, userID uuid.UUID, title, body string, data map[string]any) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SendPushToUser", ctx, userID, title, body, data)
	ret0, _ := ret[0].(error)
	return ret0
}

// SendPushToUser indicates an expected call of SendPushToUser.
func (mr *MockFirebaseAdapterMockRecorder) SendPushToUser(ctx, userID, title, body, data any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendPushToUser", reflect.TypeOf((*MockFirebaseAdapter)(nil).SendPushToUser), ctx, userID, title, body, data)
}
