// Code generated by MockGen. DO NOT EDIT.
// Source: notification_repository.go
//
// Generated by this command:
//
//	mockgen -source=notification_repository.go -destination=mocks/mock_notification_repository.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	entity "github.com/aiagent/internal/domain/entity"
	uuid "github.com/google/uuid"
	gomock "go.uber.org/mock/gomock"
)

// MockNotificationRepository is a mock of NotificationRepository interface.
type MockNotificationRepository struct {
	ctrl     *gomock.Controller
	recorder *MockNotificationRepositoryMockRecorder
	isgomock struct{}
}

// MockNotificationRepositoryMockRecorder is the mock recorder for MockNotificationRepository.
type MockNotificationRepositoryMockRecorder struct {
	mock *MockNotificationRepository
}

// NewMockNotificationRepository creates a new mock instance.
func NewMockNotificationRepository(ctrl *gomock.Controller) *MockNotificationRepository {
	mock := &MockNotificationRepository{ctrl: ctrl}
	mock.recorder = &MockNotificationRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNotificationRepository) EXPECT() *MockNotificationRepositoryMockRecorder {
	return m.recorder
}

// DeleteExpired mocks base method.
func (m *MockNotificationRepository) DeleteExpired(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteExpired", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteExpired indicates an expected call of DeleteExpired.
func (mr *MockNotificationRepositoryMockRecorder) DeleteExpired(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteExpired", reflect.TypeOf((*MockNotificationRepository)(nil).DeleteExpired), ctx)
}

// FindByUserID mocks base method.
func (m *MockNotificationRepository) FindByUserID(ctx context.Context, userID uuid.UUID, limit, offset int) ([]*entity.Notification, int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByUserID", ctx, userID, limit, offset)
	ret0, _ := ret[0].([]*entity.Notification)
	ret1, _ := ret[1].(int64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// FindByUserID indicates an expected call of FindByUserID.
func (mr *MockNotificationRepositoryMockRecorder) FindByUserID(ctx, userID, limit, offset any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByUserID", reflect.TypeOf((*MockNotificationRepository)(nil).FindByUserID), ctx, userID, limit, offset)
}

// FindRecentUnread mocks base method.
func (m *MockNotificationRepository) FindRecentUnread(ctx context.Context, userID uuid.UUID, notifType entity.NotificationType, targetID uuid.UUID, windowMinutes int) (*entity.Notification, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindRecentUnread", ctx, userID, notifType, targetID, windowMinutes)
	ret0, _ := ret[0].(*entity.Notification)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindRecentUnread indicates an expected call of FindRecentUnread.
func (mr *MockNotificationRepositoryMockRecorder) FindRecentUnread(ctx, userID, notifType, targetID, windowMinutes any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindRecentUnread", reflect.TypeOf((*MockNotificationRepository)(nil).FindRecentUnread), ctx, userID, notifType, targetID, windowMinutes)
}

// FindUnreadCount mocks base method.
func (m *MockNotificationRepository) FindUnreadCount(ctx context.Context, userID uuid.UUID) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindUnreadCount", ctx, userID)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindUnreadCount indicates an expected call of FindUnreadCount.
func (mr *MockNotificationRepositoryMockRecorder) FindUnreadCount(ctx, userID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindUnreadCount", reflect.TypeOf((*MockNotificationRepository)(nil).FindUnreadCount), ctx, userID)
}

// MarkAllAsRead mocks base method.
func (m *MockNotificationRepository) MarkAllAsRead(ctx context.Context, userID uuid.UUID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MarkAllAsRead", ctx, userID)
	ret0, _ := ret[0].(error)
	return ret0
}

// MarkAllAsRead indicates an expected call of MarkAllAsRead.
func (mr *MockNotificationRepositoryMockRecorder) MarkAllAsRead(ctx, userID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkAllAsRead", reflect.TypeOf((*MockNotificationRepository)(nil).MarkAllAsRead), ctx, userID)
}

// MarkAsRead mocks base method.
func (m *MockNotificationRepository) MarkAsRead(ctx context.Context, userID, notificationID uuid.UUID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MarkAsRead", ctx, userID, notificationID)
	ret0, _ := ret[0].(error)
	return ret0
}

// MarkAsRead indicates an expected call of MarkAsRead.
func (mr *MockNotificationRepositoryMockRecorder) MarkAsRead(ctx, userID, notificationID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkAsRead", reflect.TypeOf((*MockNotificationRepository)(nil).MarkAsRead), ctx, userID, notificationID)
}

// Save mocks base method.
func (m *MockNotificationRepository) Save(ctx context.Context, notification *entity.Notification) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Save", ctx, notification)
	ret0, _ := ret[0].(error)
	return ret0
}

// Save indicates an expected call of Save.
func (mr *MockNotificationRepositoryMockRecorder) Save(ctx, notification any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*MockNotificationRepository)(nil).Save), ctx, notification)
}

// MockNotificationPreferenceRepository is a mock of NotificationPreferenceRepository interface.
type MockNotificationPreferenceRepository struct {
	ctrl     *gomock.Controller
	recorder *MockNotificationPreferenceRepositoryMockRecorder
	isgomock struct{}
}

// MockNotificationPreferenceRepositoryMockRecorder is the mock recorder for MockNotificationPreferenceRepository.
type MockNotificationPreferenceRepositoryMockRecorder struct {
	mock *MockNotificationPreferenceRepository
}

// NewMockNotificationPreferenceRepository creates a new mock instance.
func NewMockNotificationPreferenceRepository(ctrl *gomock.Controller) *MockNotificationPreferenceRepository {
	mock := &MockNotificationPreferenceRepository{ctrl: ctrl}
	mock.recorder = &MockNotificationPreferenceRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNotificationPreferenceRepository) EXPECT() *MockNotificationPreferenceRepositoryMockRecorder {
	return m.recorder
}

// GetByUserID mocks base method.
func (m *MockNotificationPreferenceRepository) GetByUserID(ctx context.Context, userID uuid.UUID) ([]*entity.NotificationPreference, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetByUserID", ctx, userID)
	ret0, _ := ret[0].([]*entity.NotificationPreference)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByUserID indicates an expected call of GetByUserID.
func (mr *MockNotificationPreferenceRepositoryMockRecorder) GetByUserID(ctx, userID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByUserID", reflect.TypeOf((*MockNotificationPreferenceRepository)(nil).GetByUserID), ctx, userID)
}

// IsEnabled mocks base method.
func (m *MockNotificationPreferenceRepository) IsEnabled(ctx context.Context, userID uuid.UUID, notifType entity.NotificationType, channel string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsEnabled", ctx, userID, notifType, channel)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsEnabled indicates an expected call of IsEnabled.
func (mr *MockNotificationPreferenceRepositoryMockRecorder) IsEnabled(ctx, userID, notifType, channel any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsEnabled", reflect.TypeOf((*MockNotificationPreferenceRepository)(nil).IsEnabled), ctx, userID, notifType, channel)
}

// Upsert mocks base method.
func (m *MockNotificationPreferenceRepository) Upsert(ctx context.Context, preferences []*entity.NotificationPreference) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Upsert", ctx, preferences)
	ret0, _ := ret[0].(error)
	return ret0
}

// Upsert indicates an expected call of Upsert.
func (mr *MockNotificationPreferenceRepositoryMockRecorder) Upsert(ctx, preferences any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Upsert", reflect.TypeOf((*MockNotificationPreferenceRepository)(nil).Upsert), ctx, preferences)
}

// MockDeviceTokenRepository is a mock of DeviceTokenRepository interface.
type MockDeviceTokenRepository struct {
	ctrl     *gomock.Controller
	recorder *MockDeviceTokenRepositoryMockRecorder
	isgomock struct{}
}

// MockDeviceTokenRepositoryMockRecorder is the mock recorder for MockDeviceTokenRepository.
type MockDeviceTokenRepositoryMockRecorder struct {
	mock *MockDeviceTokenRepository
}

// NewMockDeviceTokenRepository creates a new mock instance.
func NewMockDeviceTokenRepository(ctrl *gomock.Controller) *MockDeviceTokenRepository {
	mock := &MockDeviceTokenRepository{ctrl: ctrl}
	mock.recorder = &MockDeviceTokenRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDeviceTokenRepository) EXPECT() *MockDeviceTokenRepositoryMockRecorder {
	return m.recorder
}

// Delete mocks base method.
func (m *MockDeviceTokenRepository) Delete(ctx context.Context, userID uuid.UUID, deviceToken string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", ctx, userID, deviceToken)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockDeviceTokenRepositoryMockRecorder) Delete(ctx, userID, deviceToken any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockDeviceTokenRepository)(nil).Delete), ctx, userID, deviceToken)
}

// DeleteStaleTokens mocks base method.
func (m *MockDeviceTokenRepository) DeleteStaleTokens(ctx context.Context, days int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteStaleTokens", ctx, days)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteStaleTokens indicates an expected call of DeleteStaleTokens.
func (mr *MockDeviceTokenRepositoryMockRecorder) DeleteStaleTokens(ctx, days any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteStaleTokens", reflect.TypeOf((*MockDeviceTokenRepository)(nil).DeleteStaleTokens), ctx, days)
}

// FindByUserID mocks base method.
func (m *MockDeviceTokenRepository) FindByUserID(ctx context.Context, userID uuid.UUID) ([]*entity.UserDeviceToken, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByUserID", ctx, userID)
	ret0, _ := ret[0].([]*entity.UserDeviceToken)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindByUserID indicates an expected call of FindByUserID.
func (mr *MockDeviceTokenRepositoryMockRecorder) FindByUserID(ctx, userID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByUserID", reflect.TypeOf((*MockDeviceTokenRepository)(nil).FindByUserID), ctx, userID)
}

// Upsert mocks base method.
func (m *MockDeviceTokenRepository) Upsert(ctx context.Context, token *entity.UserDeviceToken) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Upsert", ctx, token)
	ret0, _ := ret[0].(error)
	return ret0
}

// Upsert indicates an expected call of Upsert.
func (mr *MockDeviceTokenRepositoryMockRecorder) Upsert(ctx, token any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Upsert", reflect.TypeOf((*MockDeviceTokenRepository)(nil).Upsert), ctx, token)
}
